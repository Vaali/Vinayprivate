#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sat Apr 23 14:43:09 2016 by generateDS.py version 2.9a.
#

import sys
import getopt
import re as re_
import base64
from datetime import datetime, tzinfo, timedelta

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(tzinfo):
            def __init__(self, offset, name):
                self.__offset = timedelta(minutes = offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = input_data.strftime('%Y-%m-%dT%H:%M:%S')
            else:
                _svalue = input_data.strftime('%Y-%m-%dT%H:%M:%S.%f')
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_parse_datetime(self, input_data, node, input_name=''):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime.strptime(
                        input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime.strptime(
                        input_data, '%Y-%m-%dT%H:%M:%S')
            return dt.replace(tzinfo = tz)

        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = input_data.strftime('%Y-%m-%d')
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_parse_date(self, input_data, node, input_name=''):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            return datetime.strptime(input_data,
                '%Y-%m-%d').replace(tzinfo = tz)
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' %
                (self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class songs(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, youtubeId=None, artistId=None, overLap=None, songName=None, youtubeName=None, artist=None, ftArtistList=None, indexedftArtistList=None, indexedArtistAliasList=None, connPhraseList=None, indexedArtist=None, url=None, releaseDate=None, decade=None, youtubeDate=None, crawlDate=None, viewcount=None, crawlDelta=None, releaseId=None, masterRelease=None, masterGenres=None, masterStyles=None, crawlHistoryList=None, genresCountList=None, rating=None, level1Genres=None, level2Genres=None, level3Genres=None, level4Genres=None, level5Genres=None, level6Genres=None, level7Genres=None, level8Genres=None, level9Genres=None, albumList=None, viewcountRate=None, duration=None, descriptions=None, viewCountGroup=None, decision=None, substring_song=None, substring_artist=None, substring_ftartist=None, songLanguage=None, earliestDate=None, songCountry=None, totalMatch=None, songMatch=None, artistMatch=None, youtubeList=None, soundcloudList=None):
        self.youtubeId = youtubeId
        self.artistId = artistId
        self.overLap = overLap
        self.songName = songName
        self.youtubeName = youtubeName
        self.artist = artist
        self.ftArtistList = ftArtistList
        self.indexedftArtistList = indexedftArtistList
        self.indexedArtistAliasList = indexedArtistAliasList
        self.connPhraseList = connPhraseList
        self.indexedArtist = indexedArtist
        self.url = url
        self.releaseDate = releaseDate
        self.decade = decade
        self.youtubeDate = youtubeDate
        self.crawlDate = crawlDate
        self.viewcount = viewcount
        self.crawlDelta = crawlDelta
        self.releaseId = releaseId
        self.masterRelease = masterRelease
        self.masterGenres = masterGenres
        self.masterStyles = masterStyles
        self.crawlHistoryList = crawlHistoryList
        self.genresCountList = genresCountList
        self.rating = rating
        self.level1Genres = level1Genres
        self.level2Genres = level2Genres
        self.level3Genres = level3Genres
        self.level4Genres = level4Genres
        self.level5Genres = level5Genres
        self.level6Genres = level6Genres
        self.level7Genres = level7Genres
        self.level8Genres = level8Genres
        self.level9Genres = level9Genres
        self.albumList = albumList
        self.viewcountRate = viewcountRate
        self.duration = duration
        self.descriptions = descriptions
        self.viewCountGroup = viewCountGroup
        self.decision = decision
        self.substring_song = substring_song
        self.substring_artist = substring_artist
        self.substring_ftartist = substring_ftartist
        self.songLanguage = songLanguage
        self.earliestDate = earliestDate
        self.songCountry = songCountry
        self.totalMatch = totalMatch
        self.songMatch = songMatch
        self.artistMatch = artistMatch
        self.youtubeList = youtubeList
        self.soundcloudList = soundcloudList
    def factory(*args_, **kwargs_):
        if songs.subclass:
            return songs.subclass(*args_, **kwargs_)
        else:
            return songs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_youtubeId(self): return self.youtubeId
    def set_youtubeId(self, youtubeId): self.youtubeId = youtubeId
    def get_artistId(self): return self.artistId
    def set_artistId(self, artistId): self.artistId = artistId
    def get_overLap(self): return self.overLap
    def set_overLap(self, overLap): self.overLap = overLap
    def get_songName(self): return self.songName
    def set_songName(self, songName): self.songName = songName
    def get_youtubeName(self): return self.youtubeName
    def set_youtubeName(self, youtubeName): self.youtubeName = youtubeName
    def get_artist(self): return self.artist
    def set_artist(self, artist): self.artist = artist
    def get_ftArtistList(self): return self.ftArtistList
    def set_ftArtistList(self, ftArtistList): self.ftArtistList = ftArtistList
    def get_indexedftArtistList(self): return self.indexedftArtistList
    def set_indexedftArtistList(self, indexedftArtistList): self.indexedftArtistList = indexedftArtistList
    def get_indexedArtistAliasList(self): return self.indexedArtistAliasList
    def set_indexedArtistAliasList(self, indexedArtistAliasList): self.indexedArtistAliasList = indexedArtistAliasList
    def get_connPhraseList(self): return self.connPhraseList
    def set_connPhraseList(self, connPhraseList): self.connPhraseList = connPhraseList
    def get_indexedArtist(self): return self.indexedArtist
    def set_indexedArtist(self, indexedArtist): self.indexedArtist = indexedArtist
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_releaseDate(self): return self.releaseDate
    def set_releaseDate(self, releaseDate): self.releaseDate = releaseDate
    def get_decade(self): return self.decade
    def set_decade(self, decade): self.decade = decade
    def get_youtubeDate(self): return self.youtubeDate
    def set_youtubeDate(self, youtubeDate): self.youtubeDate = youtubeDate
    def get_crawlDate(self): return self.crawlDate
    def set_crawlDate(self, crawlDate): self.crawlDate = crawlDate
    def get_viewcount(self): return self.viewcount
    def set_viewcount(self, viewcount): self.viewcount = viewcount
    def get_crawlDelta(self): return self.crawlDelta
    def set_crawlDelta(self, crawlDelta): self.crawlDelta = crawlDelta
    def get_releaseId(self): return self.releaseId
    def set_releaseId(self, releaseId): self.releaseId = releaseId
    def get_masterRelease(self): return self.masterRelease
    def set_masterRelease(self, masterRelease): self.masterRelease = masterRelease
    def get_masterGenres(self): return self.masterGenres
    def set_masterGenres(self, masterGenres): self.masterGenres = masterGenres
    def get_masterStyles(self): return self.masterStyles
    def set_masterStyles(self, masterStyles): self.masterStyles = masterStyles
    def get_crawlHistoryList(self): return self.crawlHistoryList
    def set_crawlHistoryList(self, crawlHistoryList): self.crawlHistoryList = crawlHistoryList
    def get_genresCountList(self): return self.genresCountList
    def set_genresCountList(self, genresCountList): self.genresCountList = genresCountList
    def get_rating(self): return self.rating
    def set_rating(self, rating): self.rating = rating
    def get_level1Genres(self): return self.level1Genres
    def set_level1Genres(self, level1Genres): self.level1Genres = level1Genres
    def get_level2Genres(self): return self.level2Genres
    def set_level2Genres(self, level2Genres): self.level2Genres = level2Genres
    def get_level3Genres(self): return self.level3Genres
    def set_level3Genres(self, level3Genres): self.level3Genres = level3Genres
    def get_level4Genres(self): return self.level4Genres
    def set_level4Genres(self, level4Genres): self.level4Genres = level4Genres
    def get_level5Genres(self): return self.level5Genres
    def set_level5Genres(self, level5Genres): self.level5Genres = level5Genres
    def get_level6Genres(self): return self.level6Genres
    def set_level6Genres(self, level6Genres): self.level6Genres = level6Genres
    def get_level7Genres(self): return self.level7Genres
    def set_level7Genres(self, level7Genres): self.level7Genres = level7Genres
    def get_level8Genres(self): return self.level8Genres
    def set_level8Genres(self, level8Genres): self.level8Genres = level8Genres
    def get_level9Genres(self): return self.level9Genres
    def set_level9Genres(self, level9Genres): self.level9Genres = level9Genres
    def get_albumList(self): return self.albumList
    def set_albumList(self, albumList): self.albumList = albumList
    def get_viewcountRate(self): return self.viewcountRate
    def set_viewcountRate(self, viewcountRate): self.viewcountRate = viewcountRate
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_descriptions(self): return self.descriptions
    def set_descriptions(self, descriptions): self.descriptions = descriptions
    def get_viewCountGroup(self): return self.viewCountGroup
    def set_viewCountGroup(self, viewCountGroup): self.viewCountGroup = viewCountGroup
    def get_decision(self): return self.decision
    def set_decision(self, decision): self.decision = decision
    def get_substring_song(self): return self.substring_song
    def set_substring_song(self, substring_song): self.substring_song = substring_song
    def get_substring_artist(self): return self.substring_artist
    def set_substring_artist(self, substring_artist): self.substring_artist = substring_artist
    def get_substring_ftartist(self): return self.substring_ftartist
    def set_substring_ftartist(self, substring_ftartist): self.substring_ftartist = substring_ftartist
    def get_songLanguage(self): return self.songLanguage
    def set_songLanguage(self, songLanguage): self.songLanguage = songLanguage
    def get_earliestDate(self): return self.earliestDate
    def set_earliestDate(self, earliestDate): self.earliestDate = earliestDate
    def get_songCountry(self): return self.songCountry
    def set_songCountry(self, songCountry): self.songCountry = songCountry
    def get_totalMatch(self): return self.totalMatch
    def set_totalMatch(self, totalMatch): self.totalMatch = totalMatch
    def get_songMatch(self): return self.songMatch
    def set_songMatch(self, songMatch): self.songMatch = songMatch
    def get_artistMatch(self): return self.artistMatch
    def set_artistMatch(self, artistMatch): self.artistMatch = artistMatch
    def get_youtubeList(self): return self.youtubeList
    def set_youtubeList(self, youtubeList): self.youtubeList = youtubeList
    def get_soundcloudList(self): return self.soundcloudList
    def set_soundcloudList(self, soundcloudList): self.soundcloudList = soundcloudList
    def hasContent_(self):
        if (
            self.youtubeId is not None or
            self.artistId is not None or
            self.overLap is not None or
            self.songName is not None or
            self.youtubeName is not None or
            self.artist is not None or
            self.ftArtistList is not None or
            self.indexedftArtistList is not None or
            self.indexedArtistAliasList is not None or
            self.connPhraseList is not None or
            self.indexedArtist is not None or
            self.url is not None or
            self.releaseDate is not None or
            self.decade is not None or
            self.youtubeDate is not None or
            self.crawlDate is not None or
            self.viewcount is not None or
            self.crawlDelta is not None or
            self.releaseId is not None or
            self.masterRelease is not None or
            self.masterGenres is not None or
            self.masterStyles is not None or
            self.crawlHistoryList is not None or
            self.genresCountList is not None or
            self.rating is not None or
            self.level1Genres is not None or
            self.level2Genres is not None or
            self.level3Genres is not None or
            self.level4Genres is not None or
            self.level5Genres is not None or
            self.level6Genres is not None or
            self.level7Genres is not None or
            self.level8Genres is not None or
            self.level9Genres is not None or
            self.albumList is not None or
            self.viewcountRate is not None or
            self.duration is not None or
            self.descriptions is not None or
            self.viewCountGroup is not None or
            self.decision is not None or
            self.substring_song is not None or
            self.substring_artist is not None or
            self.substring_ftartist is not None or
            self.songLanguage is not None or
            self.earliestDate is not None or
            self.songCountry is not None or
            self.totalMatch is not None or
            self.songMatch is not None or
            self.artistMatch is not None or
            self.youtubeList is not None or
            self.soundcloudList is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='songs', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='songs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='songs'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='songs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.youtubeId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%syoutubeId>%s</%syoutubeId>%s' % (namespace_, self.gds_format_string(quote_xml(self.youtubeId).encode(ExternalEncoding), input_name='youtubeId'), namespace_, eol_))
        if self.artistId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sartistId>%s</%sartistId>%s' % (namespace_, self.gds_format_integer(self.artistId, input_name='artistId'), namespace_, eol_))
        if self.overLap is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soverLap>%s</%soverLap>%s' % (namespace_, self.gds_format_string(quote_xml(self.overLap).encode(ExternalEncoding), input_name='overLap'), namespace_, eol_))
        if self.songName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssongName>%s</%ssongName>%s' % (namespace_, self.gds_format_string(quote_xml(self.songName).encode(ExternalEncoding), input_name='songName'), namespace_, eol_))
        if self.youtubeName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%syoutubeName>%s</%syoutubeName>%s' % (namespace_, self.gds_format_string(quote_xml(self.youtubeName).encode(ExternalEncoding), input_name='youtubeName'), namespace_, eol_))
        if self.artist is not None:
            self.artist.export(outfile, level, namespace_, name_='artist', pretty_print=pretty_print)
        if self.ftArtistList is not None:
            self.ftArtistList.export(outfile, level, namespace_, name_='ftArtistList', pretty_print=pretty_print)
        if self.indexedftArtistList is not None:
            self.indexedftArtistList.export(outfile, level, namespace_, name_='indexedftArtistList', pretty_print=pretty_print)
        if self.indexedArtistAliasList is not None:
            self.indexedArtistAliasList.export(outfile, level, namespace_, name_='indexedArtistAliasList', pretty_print=pretty_print)
        if self.connPhraseList is not None:
            self.connPhraseList.export(outfile, level, namespace_, name_='connPhraseList', pretty_print=pretty_print)
        if self.indexedArtist is not None:
            self.indexedArtist.export(outfile, level, namespace_, name_='indexedArtist', pretty_print=pretty_print)
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl>%s</%surl>%s' % (namespace_, self.gds_format_string(quote_xml(self.url).encode(ExternalEncoding), input_name='url'), namespace_, eol_))
        if self.releaseDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreleaseDate>%s</%sreleaseDate>%s' % (namespace_, self.gds_format_integer(self.releaseDate, input_name='releaseDate'), namespace_, eol_))
        if self.decade is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdecade>%s</%sdecade>%s' % (namespace_, self.gds_format_integer(self.decade, input_name='decade'), namespace_, eol_))
        if self.youtubeDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%syoutubeDate>%s</%syoutubeDate>%s' % (namespace_, self.gds_format_date(self.youtubeDate, input_name='youtubeDate'), namespace_, eol_))
        if self.crawlDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scrawlDate>%s</%scrawlDate>%s' % (namespace_, self.gds_format_date(self.crawlDate, input_name='crawlDate'), namespace_, eol_))
        if self.viewcount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sviewcount>%s</%sviewcount>%s' % (namespace_, self.gds_format_integer(self.viewcount, input_name='viewcount'), namespace_, eol_))
        if self.crawlDelta is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scrawlDelta>%s</%scrawlDelta>%s' % (namespace_, self.gds_format_integer(self.crawlDelta, input_name='crawlDelta'), namespace_, eol_))
        if self.releaseId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreleaseId>%s</%sreleaseId>%s' % (namespace_, self.gds_format_integer(self.releaseId, input_name='releaseId'), namespace_, eol_))
        if self.masterRelease is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterRelease>%s</%smasterRelease>%s' % (namespace_, self.gds_format_integer(self.masterRelease, input_name='masterRelease'), namespace_, eol_))
        if self.masterGenres is not None:
            self.masterGenres.export(outfile, level, namespace_, name_='masterGenres', pretty_print=pretty_print)
        if self.masterStyles is not None:
            self.masterStyles.export(outfile, level, namespace_, name_='masterStyles', pretty_print=pretty_print)
        if self.crawlHistoryList is not None:
            self.crawlHistoryList.export(outfile, level, namespace_, name_='crawlHistoryList', pretty_print=pretty_print)
        if self.genresCountList is not None:
            self.genresCountList.export(outfile, level, namespace_, name_='genresCountList', pretty_print=pretty_print)
        if self.rating is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srating>%s</%srating>%s' % (namespace_, self.gds_format_float(self.rating, input_name='rating'), namespace_, eol_))
        if self.level1Genres is not None:
            self.level1Genres.export(outfile, level, namespace_, name_='level1Genres', pretty_print=pretty_print)
        if self.level2Genres is not None:
            self.level2Genres.export(outfile, level, namespace_, name_='level2Genres', pretty_print=pretty_print)
        if self.level3Genres is not None:
            self.level3Genres.export(outfile, level, namespace_, name_='level3Genres', pretty_print=pretty_print)
        if self.level4Genres is not None:
            self.level4Genres.export(outfile, level, namespace_, name_='level4Genres', pretty_print=pretty_print)
        if self.level5Genres is not None:
            self.level5Genres.export(outfile, level, namespace_, name_='level5Genres', pretty_print=pretty_print)
        if self.level6Genres is not None:
            self.level6Genres.export(outfile, level, namespace_, name_='level6Genres', pretty_print=pretty_print)
        if self.level7Genres is not None:
            self.level7Genres.export(outfile, level, namespace_, name_='level7Genres', pretty_print=pretty_print)
        if self.level8Genres is not None:
            self.level8Genres.export(outfile, level, namespace_, name_='level8Genres', pretty_print=pretty_print)
        if self.level9Genres is not None:
            self.level9Genres.export(outfile, level, namespace_, name_='level9Genres', pretty_print=pretty_print)
        if self.albumList is not None:
            self.albumList.export(outfile, level, namespace_, name_='albumList', pretty_print=pretty_print)
        if self.viewcountRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sviewcountRate>%s</%sviewcountRate>%s' % (namespace_, self.gds_format_float(self.viewcountRate, input_name='viewcountRate'), namespace_, eol_))
        if self.duration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sduration>%s</%sduration>%s' % (namespace_, self.gds_format_string(quote_xml(self.duration).encode(ExternalEncoding), input_name='duration'), namespace_, eol_))
        if self.descriptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescriptions>%s</%sdescriptions>%s' % (namespace_, self.gds_format_string(quote_xml(self.descriptions).encode(ExternalEncoding), input_name='descriptions'), namespace_, eol_))
        if self.viewCountGroup is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sviewCountGroup>%s</%sviewCountGroup>%s' % (namespace_, self.gds_format_integer(self.viewCountGroup, input_name='viewCountGroup'), namespace_, eol_))
        if self.decision is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdecision>%s</%sdecision>%s' % (namespace_, self.gds_format_string(quote_xml(self.decision).encode(ExternalEncoding), input_name='decision'), namespace_, eol_))
        if self.substring_song is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubstring_song>%s</%ssubstring_song>%s' % (namespace_, self.gds_format_string(quote_xml(self.substring_song).encode(ExternalEncoding), input_name='substring_song'), namespace_, eol_))
        if self.substring_artist is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubstring_artist>%s</%ssubstring_artist>%s' % (namespace_, self.gds_format_string(quote_xml(self.substring_artist).encode(ExternalEncoding), input_name='substring_artist'), namespace_, eol_))
        if self.substring_ftartist is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubstring_ftartist>%s</%ssubstring_ftartist>%s' % (namespace_, self.gds_format_string(quote_xml(self.substring_ftartist).encode(ExternalEncoding), input_name='substring_ftartist'), namespace_, eol_))
        if self.songLanguage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssongLanguage>%s</%ssongLanguage>%s' % (namespace_, self.gds_format_string(quote_xml(self.songLanguage).encode(ExternalEncoding), input_name='songLanguage'), namespace_, eol_))
        if self.earliestDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%searliestDate>%s</%searliestDate>%s' % (namespace_, self.gds_format_string(quote_xml(self.earliestDate).encode(ExternalEncoding), input_name='earliestDate'), namespace_, eol_))
        if self.songCountry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssongCountry>%s</%ssongCountry>%s' % (namespace_, self.gds_format_string(quote_xml(self.songCountry).encode(ExternalEncoding), input_name='songCountry'), namespace_, eol_))
        if self.totalMatch is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalMatch>%s</%stotalMatch>%s' % (namespace_, self.gds_format_float(self.totalMatch, input_name='totalMatch'), namespace_, eol_))
        if self.songMatch is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssongMatch>%s</%ssongMatch>%s' % (namespace_, self.gds_format_float(self.songMatch, input_name='songMatch'), namespace_, eol_))
        if self.artistMatch is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sartistMatch>%s</%sartistMatch>%s' % (namespace_, self.gds_format_float(self.artistMatch, input_name='artistMatch'), namespace_, eol_))
        if self.youtubeList is not None:
            self.youtubeList.export(outfile, level, namespace_, name_='youtubeList', pretty_print=pretty_print)
        if self.soundcloudList is not None:
            self.soundcloudList.export(outfile, level, namespace_, name_='soundcloudList', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='songs'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.youtubeId is not None:
            showIndent(outfile, level)
            outfile.write('youtubeId=%s,\n' % quote_python(self.youtubeId).encode(ExternalEncoding))
        if self.artistId is not None:
            showIndent(outfile, level)
            outfile.write('artistId=%d,\n' % self.artistId)
        if self.overLap is not None:
            showIndent(outfile, level)
            outfile.write('overLap=%s,\n' % quote_python(self.overLap).encode(ExternalEncoding))
        if self.songName is not None:
            showIndent(outfile, level)
            outfile.write('songName=%s,\n' % quote_python(self.songName).encode(ExternalEncoding))
        if self.youtubeName is not None:
            showIndent(outfile, level)
            outfile.write('youtubeName=%s,\n' % quote_python(self.youtubeName).encode(ExternalEncoding))
        if self.artist is not None:
            showIndent(outfile, level)
            outfile.write('artist=model_.artist(\n')
            self.artist.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ftArtistList is not None:
            showIndent(outfile, level)
            outfile.write('ftArtistList=model_.ftArtistList(\n')
            self.ftArtistList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.indexedftArtistList is not None:
            showIndent(outfile, level)
            outfile.write('indexedftArtistList=model_.indexedftArtistList(\n')
            self.indexedftArtistList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.indexedArtistAliasList is not None:
            showIndent(outfile, level)
            outfile.write('indexedArtistAliasList=model_.indexedArtistAliasList(\n')
            self.indexedArtistAliasList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.connPhraseList is not None:
            showIndent(outfile, level)
            outfile.write('connPhraseList=model_.connPhraseList(\n')
            self.connPhraseList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.indexedArtist is not None:
            showIndent(outfile, level)
            outfile.write('indexedArtist=model_.indexedArtist(\n')
            self.indexedArtist.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.url is not None:
            showIndent(outfile, level)
            outfile.write('url=%s,\n' % quote_python(self.url).encode(ExternalEncoding))
        if self.releaseDate is not None:
            showIndent(outfile, level)
            outfile.write('releaseDate=%d,\n' % self.releaseDate)
        if self.decade is not None:
            showIndent(outfile, level)
            outfile.write('decade=%d,\n' % self.decade)
        if self.youtubeDate is not None:
            showIndent(outfile, level)
            outfile.write('youtubeDate=datetime_.strptime("%s", "%%Y-%%m-%%d"),\n' % self.gds_format_date(self.youtubeDate, input_name='youtubeDate'))
        if self.crawlDate is not None:
            showIndent(outfile, level)
            outfile.write('crawlDate=datetime_.strptime("%s", "%%Y-%%m-%%d"),\n' % self.gds_format_date(self.crawlDate, input_name='crawlDate'))
        if self.viewcount is not None:
            showIndent(outfile, level)
            outfile.write('viewcount=%d,\n' % self.viewcount)
        if self.crawlDelta is not None:
            showIndent(outfile, level)
            outfile.write('crawlDelta=%d,\n' % self.crawlDelta)
        if self.releaseId is not None:
            showIndent(outfile, level)
            outfile.write('releaseId=%d,\n' % self.releaseId)
        if self.masterRelease is not None:
            showIndent(outfile, level)
            outfile.write('masterRelease=%d,\n' % self.masterRelease)
        if self.masterGenres is not None:
            showIndent(outfile, level)
            outfile.write('masterGenres=model_.masterGenres(\n')
            self.masterGenres.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.masterStyles is not None:
            showIndent(outfile, level)
            outfile.write('masterStyles=model_.masterStyles(\n')
            self.masterStyles.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.crawlHistoryList is not None:
            showIndent(outfile, level)
            outfile.write('crawlHistoryList=model_.crawlHistoryList(\n')
            self.crawlHistoryList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.genresCountList is not None:
            showIndent(outfile, level)
            outfile.write('genresCountList=model_.genresCountList(\n')
            self.genresCountList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rating is not None:
            showIndent(outfile, level)
            outfile.write('rating=%f,\n' % self.rating)
        if self.level1Genres is not None:
            showIndent(outfile, level)
            outfile.write('level1Genres=model_.level1Genres(\n')
            self.level1Genres.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.level2Genres is not None:
            showIndent(outfile, level)
            outfile.write('level2Genres=model_.level2Genres(\n')
            self.level2Genres.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.level3Genres is not None:
            showIndent(outfile, level)
            outfile.write('level3Genres=model_.level3Genres(\n')
            self.level3Genres.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.level4Genres is not None:
            showIndent(outfile, level)
            outfile.write('level4Genres=model_.level4Genres(\n')
            self.level4Genres.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.level5Genres is not None:
            showIndent(outfile, level)
            outfile.write('level5Genres=model_.level5Genres(\n')
            self.level5Genres.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.level6Genres is not None:
            showIndent(outfile, level)
            outfile.write('level6Genres=model_.level6Genres(\n')
            self.level6Genres.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.level7Genres is not None:
            showIndent(outfile, level)
            outfile.write('level7Genres=model_.level7Genres(\n')
            self.level7Genres.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.level8Genres is not None:
            showIndent(outfile, level)
            outfile.write('level8Genres=model_.level8Genres(\n')
            self.level8Genres.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.level9Genres is not None:
            showIndent(outfile, level)
            outfile.write('level9Genres=model_.level9Genres(\n')
            self.level9Genres.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.albumList is not None:
            showIndent(outfile, level)
            outfile.write('albumList=model_.albumList(\n')
            self.albumList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.viewcountRate is not None:
            showIndent(outfile, level)
            outfile.write('viewcountRate=%f,\n' % self.viewcountRate)
        if self.duration is not None:
            showIndent(outfile, level)
            outfile.write('duration=%s,\n' % quote_python(self.duration).encode(ExternalEncoding))
        if self.descriptions is not None:
            showIndent(outfile, level)
            outfile.write('descriptions=%s,\n' % quote_python(self.descriptions).encode(ExternalEncoding))
        if self.viewCountGroup is not None:
            showIndent(outfile, level)
            outfile.write('viewCountGroup=%d,\n' % self.viewCountGroup)
        if self.decision is not None:
            showIndent(outfile, level)
            outfile.write('decision=%s,\n' % quote_python(self.decision).encode(ExternalEncoding))
        if self.substring_song is not None:
            showIndent(outfile, level)
            outfile.write('substring_song=%s,\n' % quote_python(self.substring_song).encode(ExternalEncoding))
        if self.substring_artist is not None:
            showIndent(outfile, level)
            outfile.write('substring_artist=%s,\n' % quote_python(self.substring_artist).encode(ExternalEncoding))
        if self.substring_ftartist is not None:
            showIndent(outfile, level)
            outfile.write('substring_ftartist=%s,\n' % quote_python(self.substring_ftartist).encode(ExternalEncoding))
        if self.songLanguage is not None:
            showIndent(outfile, level)
            outfile.write('songLanguage=%s,\n' % quote_python(self.songLanguage).encode(ExternalEncoding))
        if self.earliestDate is not None:
            showIndent(outfile, level)
            outfile.write('earliestDate=%s,\n' % quote_python(self.earliestDate).encode(ExternalEncoding))
        if self.songCountry is not None:
            showIndent(outfile, level)
            outfile.write('songCountry=%s,\n' % quote_python(self.songCountry).encode(ExternalEncoding))
        if self.totalMatch is not None:
            showIndent(outfile, level)
            outfile.write('totalMatch=%f,\n' % self.totalMatch)
        if self.songMatch is not None:
            showIndent(outfile, level)
            outfile.write('songMatch=%f,\n' % self.songMatch)
        if self.artistMatch is not None:
            showIndent(outfile, level)
            outfile.write('artistMatch=%f,\n' % self.artistMatch)
        if self.youtubeList is not None:
            showIndent(outfile, level)
            outfile.write('youtubeList=model_.youtubeList(\n')
            self.youtubeList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.soundcloudList is not None:
            showIndent(outfile, level)
            outfile.write('soundcloudList=model_.soundcloudList(\n')
            self.soundcloudList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'youtubeId':
            youtubeId_ = child_.text
            youtubeId_ = self.gds_validate_string(youtubeId_, node, 'youtubeId')
            self.youtubeId = youtubeId_
        elif nodeName_ == 'artistId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'artistId')
            self.artistId = ival_
        elif nodeName_ == 'overLap':
            overLap_ = child_.text
            overLap_ = self.gds_validate_string(overLap_, node, 'overLap')
            self.overLap = overLap_
        elif nodeName_ == 'songName':
            songName_ = child_.text
            songName_ = self.gds_validate_string(songName_, node, 'songName')
            self.songName = songName_
        elif nodeName_ == 'youtubeName':
            youtubeName_ = child_.text
            youtubeName_ = self.gds_validate_string(youtubeName_, node, 'youtubeName')
            self.youtubeName = youtubeName_
        elif nodeName_ == 'artist':
            obj_ = artist.factory()
            obj_.build(child_)
            self.set_artist(obj_)
        elif nodeName_ == 'ftArtistList':
            obj_ = ftArtistList.factory()
            obj_.build(child_)
            self.set_ftArtistList(obj_)
        elif nodeName_ == 'indexedftArtistList':
            obj_ = indexedftArtistList.factory()
            obj_.build(child_)
            self.set_indexedftArtistList(obj_)
        elif nodeName_ == 'indexedArtistAliasList':
            obj_ = indexedArtistAliasList.factory()
            obj_.build(child_)
            self.set_indexedArtistAliasList(obj_)
        elif nodeName_ == 'connPhraseList':
            obj_ = connPhraseList.factory()
            obj_.build(child_)
            self.set_connPhraseList(obj_)
        elif nodeName_ == 'indexedArtist':
            obj_ = indexedArtist.factory()
            obj_.build(child_)
            self.set_indexedArtist(obj_)
        elif nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
        elif nodeName_ == 'releaseDate':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'releaseDate')
            self.releaseDate = ival_
        elif nodeName_ == 'decade':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'decade')
            self.decade = ival_
        elif nodeName_ == 'youtubeDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_, node, 'youtubeDate')
            self.youtubeDate = dval_
        elif nodeName_ == 'crawlDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_, node, 'crawlDate')
            self.crawlDate = dval_
        elif nodeName_ == 'viewcount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'viewcount')
            self.viewcount = ival_
        elif nodeName_ == 'crawlDelta':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'crawlDelta')
            self.crawlDelta = ival_
        elif nodeName_ == 'releaseId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'releaseId')
            self.releaseId = ival_
        elif nodeName_ == 'masterRelease':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'masterRelease')
            self.masterRelease = ival_
        elif nodeName_ == 'masterGenres':
            obj_ = masterGenres.factory()
            obj_.build(child_)
            self.set_masterGenres(obj_)
        elif nodeName_ == 'masterStyles':
            obj_ = masterStyles.factory()
            obj_.build(child_)
            self.set_masterStyles(obj_)
        elif nodeName_ == 'crawlHistoryList':
            obj_ = crawlHistoryList.factory()
            obj_.build(child_)
            self.set_crawlHistoryList(obj_)
        elif nodeName_ == 'genresCountList':
            obj_ = genresCountList.factory()
            obj_.build(child_)
            self.set_genresCountList(obj_)
        elif nodeName_ == 'rating':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'rating')
            self.rating = fval_
        elif nodeName_ == 'level1Genres':
            obj_ = level1Genres.factory()
            obj_.build(child_)
            self.set_level1Genres(obj_)
        elif nodeName_ == 'level2Genres':
            obj_ = level2Genres.factory()
            obj_.build(child_)
            self.set_level2Genres(obj_)
        elif nodeName_ == 'level3Genres':
            obj_ = level3Genres.factory()
            obj_.build(child_)
            self.set_level3Genres(obj_)
        elif nodeName_ == 'level4Genres':
            obj_ = level4Genres.factory()
            obj_.build(child_)
            self.set_level4Genres(obj_)
        elif nodeName_ == 'level5Genres':
            obj_ = level5Genres.factory()
            obj_.build(child_)
            self.set_level5Genres(obj_)
        elif nodeName_ == 'level6Genres':
            obj_ = level6Genres.factory()
            obj_.build(child_)
            self.set_level6Genres(obj_)
        elif nodeName_ == 'level7Genres':
            obj_ = level7Genres.factory()
            obj_.build(child_)
            self.set_level7Genres(obj_)
        elif nodeName_ == 'level8Genres':
            obj_ = level8Genres.factory()
            obj_.build(child_)
            self.set_level8Genres(obj_)
        elif nodeName_ == 'level9Genres':
            obj_ = level9Genres.factory()
            obj_.build(child_)
            self.set_level9Genres(obj_)
        elif nodeName_ == 'albumList':
            obj_ = albumList.factory()
            obj_.build(child_)
            self.set_albumList(obj_)
        elif nodeName_ == 'viewcountRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'viewcountRate')
            self.viewcountRate = fval_
        elif nodeName_ == 'duration':
            duration_ = child_.text
            duration_ = self.gds_validate_string(duration_, node, 'duration')
            self.duration = duration_
        elif nodeName_ == 'descriptions':
            descriptions_ = child_.text
            descriptions_ = self.gds_validate_string(descriptions_, node, 'descriptions')
            self.descriptions = descriptions_
        elif nodeName_ == 'viewCountGroup':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'viewCountGroup')
            self.viewCountGroup = ival_
        elif nodeName_ == 'decision':
            decision_ = child_.text
            decision_ = self.gds_validate_string(decision_, node, 'decision')
            self.decision = decision_
        elif nodeName_ == 'substring_song':
            substring_song_ = child_.text
            substring_song_ = self.gds_validate_string(substring_song_, node, 'substring_song')
            self.substring_song = substring_song_
        elif nodeName_ == 'substring_artist':
            substring_artist_ = child_.text
            substring_artist_ = self.gds_validate_string(substring_artist_, node, 'substring_artist')
            self.substring_artist = substring_artist_
        elif nodeName_ == 'substring_ftartist':
            substring_ftartist_ = child_.text
            substring_ftartist_ = self.gds_validate_string(substring_ftartist_, node, 'substring_ftartist')
            self.substring_ftartist = substring_ftartist_
        elif nodeName_ == 'songLanguage':
            songLanguage_ = child_.text
            songLanguage_ = self.gds_validate_string(songLanguage_, node, 'songLanguage')
            self.songLanguage = songLanguage_
        elif nodeName_ == 'earliestDate':
            earliestDate_ = child_.text
            earliestDate_ = self.gds_validate_string(earliestDate_, node, 'earliestDate')
            self.earliestDate = earliestDate_
        elif nodeName_ == 'songCountry':
            songCountry_ = child_.text
            songCountry_ = self.gds_validate_string(songCountry_, node, 'songCountry')
            self.songCountry = songCountry_
        elif nodeName_ == 'totalMatch':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'totalMatch')
            self.totalMatch = fval_
        elif nodeName_ == 'songMatch':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'songMatch')
            self.songMatch = fval_
        elif nodeName_ == 'artistMatch':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'artistMatch')
            self.artistMatch = fval_
        elif nodeName_ == 'youtubeList':
            obj_ = youtubeList.factory()
            obj_.build(child_)
            self.set_youtubeList(obj_)
        elif nodeName_ == 'soundcloudList':
            obj_ = soundcloudList.factory()
            obj_.build(child_)
            self.set_soundcloudList(obj_)
# end class songs


class artist(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, artistName=None, artistAlias=None, artistPopularityAll=None, artistPopularityRecent=None):
        if artistName is None:
            self.artistName = []
        else:
            self.artistName = artistName
        if artistAlias is None:
            self.artistAlias = []
        else:
            self.artistAlias = artistAlias
        self.artistPopularityAll = artistPopularityAll
        self.artistPopularityRecent = artistPopularityRecent
    def factory(*args_, **kwargs_):
        if artist.subclass:
            return artist.subclass(*args_, **kwargs_)
        else:
            return artist(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_artistName(self): return self.artistName
    def set_artistName(self, artistName): self.artistName = artistName
    def add_artistName(self, value): self.artistName.append(value)
    def insert_artistName(self, index, value): self.artistName[index] = value
    def get_artistAlias(self): return self.artistAlias
    def set_artistAlias(self, artistAlias): self.artistAlias = artistAlias
    def add_artistAlias(self, value): self.artistAlias.append(value)
    def insert_artistAlias(self, index, value): self.artistAlias[index] = value
    def get_artistPopularityAll(self): return self.artistPopularityAll
    def set_artistPopularityAll(self, artistPopularityAll): self.artistPopularityAll = artistPopularityAll
    def get_artistPopularityRecent(self): return self.artistPopularityRecent
    def set_artistPopularityRecent(self, artistPopularityRecent): self.artistPopularityRecent = artistPopularityRecent
    def hasContent_(self):
        if (
            self.artistName or
            self.artistAlias or
            self.artistPopularityAll is not None or
            self.artistPopularityRecent is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='artist', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='artist')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='artist'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='artist', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for artistName_ in self.artistName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sartistName>%s</%sartistName>%s' % (namespace_, self.gds_format_string(quote_xml(artistName_).encode(ExternalEncoding), input_name='artistName'), namespace_, eol_))
        for artistAlias_ in self.artistAlias:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sartistAlias>%s</%sartistAlias>%s' % (namespace_, self.gds_format_string(quote_xml(artistAlias_).encode(ExternalEncoding), input_name='artistAlias'), namespace_, eol_))
        if self.artistPopularityAll is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sartistPopularityAll>%s</%sartistPopularityAll>%s' % (namespace_, self.gds_format_integer(self.artistPopularityAll, input_name='artistPopularityAll'), namespace_, eol_))
        if self.artistPopularityRecent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sartistPopularityRecent>%s</%sartistPopularityRecent>%s' % (namespace_, self.gds_format_integer(self.artistPopularityRecent, input_name='artistPopularityRecent'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='artist'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('artistName=[\n')
        level += 1
        for artistName_ in self.artistName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(artistName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('artistAlias=[\n')
        level += 1
        for artistAlias_ in self.artistAlias:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(artistAlias_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.artistPopularityAll is not None:
            showIndent(outfile, level)
            outfile.write('artistPopularityAll=%d,\n' % self.artistPopularityAll)
        if self.artistPopularityRecent is not None:
            showIndent(outfile, level)
            outfile.write('artistPopularityRecent=%d,\n' % self.artistPopularityRecent)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'artistName':
            artistName_ = child_.text
            artistName_ = self.gds_validate_string(artistName_, node, 'artistName')
            self.artistName.append(artistName_)
        elif nodeName_ == 'artistAlias':
            artistAlias_ = child_.text
            artistAlias_ = self.gds_validate_string(artistAlias_, node, 'artistAlias')
            self.artistAlias.append(artistAlias_)
        elif nodeName_ == 'artistPopularityAll':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'artistPopularityAll')
            self.artistPopularityAll = ival_
        elif nodeName_ == 'artistPopularityRecent':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'artistPopularityRecent')
            self.artistPopularityRecent = ival_
# end class artist


class ftArtistList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ftArtistName=None):
        if ftArtistName is None:
            self.ftArtistName = []
        else:
            self.ftArtistName = ftArtistName
    def factory(*args_, **kwargs_):
        if ftArtistList.subclass:
            return ftArtistList.subclass(*args_, **kwargs_)
        else:
            return ftArtistList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ftArtistName(self): return self.ftArtistName
    def set_ftArtistName(self, ftArtistName): self.ftArtistName = ftArtistName
    def add_ftArtistName(self, value): self.ftArtistName.append(value)
    def insert_ftArtistName(self, index, value): self.ftArtistName[index] = value
    def hasContent_(self):
        if (
            self.ftArtistName
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ftArtistList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ftArtistList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ftArtistList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ftArtistList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ftArtistName_ in self.ftArtistName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sftArtistName>%s</%sftArtistName>%s' % (namespace_, self.gds_format_string(quote_xml(ftArtistName_).encode(ExternalEncoding), input_name='ftArtistName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ftArtistList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ftArtistName=[\n')
        level += 1
        for ftArtistName_ in self.ftArtistName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ftArtistName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ftArtistName':
            ftArtistName_ = child_.text
            ftArtistName_ = self.gds_validate_string(ftArtistName_, node, 'ftArtistName')
            self.ftArtistName.append(ftArtistName_)
# end class ftArtistList


class indexedftArtistList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, indexedftArtistName=None):
        if indexedftArtistName is None:
            self.indexedftArtistName = []
        else:
            self.indexedftArtistName = indexedftArtistName
    def factory(*args_, **kwargs_):
        if indexedftArtistList.subclass:
            return indexedftArtistList.subclass(*args_, **kwargs_)
        else:
            return indexedftArtistList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexedftArtistName(self): return self.indexedftArtistName
    def set_indexedftArtistName(self, indexedftArtistName): self.indexedftArtistName = indexedftArtistName
    def add_indexedftArtistName(self, value): self.indexedftArtistName.append(value)
    def insert_indexedftArtistName(self, index, value): self.indexedftArtistName[index] = value
    def hasContent_(self):
        if (
            self.indexedftArtistName
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indexedftArtistList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indexedftArtistList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indexedftArtistList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indexedftArtistList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for indexedftArtistName_ in self.indexedftArtistName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindexedftArtistName>%s</%sindexedftArtistName>%s' % (namespace_, self.gds_format_string(quote_xml(indexedftArtistName_).encode(ExternalEncoding), input_name='indexedftArtistName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='indexedftArtistList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('indexedftArtistName=[\n')
        level += 1
        for indexedftArtistName_ in self.indexedftArtistName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(indexedftArtistName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indexedftArtistName':
            indexedftArtistName_ = child_.text
            indexedftArtistName_ = self.gds_validate_string(indexedftArtistName_, node, 'indexedftArtistName')
            self.indexedftArtistName.append(indexedftArtistName_)
# end class indexedftArtistList


class indexedArtistAliasList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, indexedArtistAliasName=None):
        if indexedArtistAliasName is None:
            self.indexedArtistAliasName = []
        else:
            self.indexedArtistAliasName = indexedArtistAliasName
    def factory(*args_, **kwargs_):
        if indexedArtistAliasList.subclass:
            return indexedArtistAliasList.subclass(*args_, **kwargs_)
        else:
            return indexedArtistAliasList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexedArtistAliasName(self): return self.indexedArtistAliasName
    def set_indexedArtistAliasName(self, indexedArtistAliasName): self.indexedArtistAliasName = indexedArtistAliasName
    def add_indexedArtistAliasName(self, value): self.indexedArtistAliasName.append(value)
    def insert_indexedArtistAliasName(self, index, value): self.indexedArtistAliasName[index] = value
    def hasContent_(self):
        if (
            self.indexedArtistAliasName
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indexedArtistAliasList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indexedArtistAliasList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indexedArtistAliasList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indexedArtistAliasList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for indexedArtistAliasName_ in self.indexedArtistAliasName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindexedArtistAliasName>%s</%sindexedArtistAliasName>%s' % (namespace_, self.gds_format_string(quote_xml(indexedArtistAliasName_).encode(ExternalEncoding), input_name='indexedArtistAliasName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='indexedArtistAliasList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('indexedArtistAliasName=[\n')
        level += 1
        for indexedArtistAliasName_ in self.indexedArtistAliasName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(indexedArtistAliasName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indexedArtistAliasName':
            indexedArtistAliasName_ = child_.text
            indexedArtistAliasName_ = self.gds_validate_string(indexedArtistAliasName_, node, 'indexedArtistAliasName')
            self.indexedArtistAliasName.append(indexedArtistAliasName_)
# end class indexedArtistAliasList


class connPhraseList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, connPhrase=None):
        if connPhrase is None:
            self.connPhrase = []
        else:
            self.connPhrase = connPhrase
    def factory(*args_, **kwargs_):
        if connPhraseList.subclass:
            return connPhraseList.subclass(*args_, **kwargs_)
        else:
            return connPhraseList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_connPhrase(self): return self.connPhrase
    def set_connPhrase(self, connPhrase): self.connPhrase = connPhrase
    def add_connPhrase(self, value): self.connPhrase.append(value)
    def insert_connPhrase(self, index, value): self.connPhrase[index] = value
    def hasContent_(self):
        if (
            self.connPhrase
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='connPhraseList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='connPhraseList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='connPhraseList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='connPhraseList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for connPhrase_ in self.connPhrase:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconnPhrase>%s</%sconnPhrase>%s' % (namespace_, self.gds_format_string(quote_xml(connPhrase_).encode(ExternalEncoding), input_name='connPhrase'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='connPhraseList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('connPhrase=[\n')
        level += 1
        for connPhrase_ in self.connPhrase:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(connPhrase_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'connPhrase':
            connPhrase_ = child_.text
            connPhrase_ = self.gds_validate_string(connPhrase_, node, 'connPhrase')
            self.connPhrase.append(connPhrase_)
# end class connPhraseList


class indexedArtist(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, indexedArtistName=None):
        if indexedArtistName is None:
            self.indexedArtistName = []
        else:
            self.indexedArtistName = indexedArtistName
    def factory(*args_, **kwargs_):
        if indexedArtist.subclass:
            return indexedArtist.subclass(*args_, **kwargs_)
        else:
            return indexedArtist(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexedArtistName(self): return self.indexedArtistName
    def set_indexedArtistName(self, indexedArtistName): self.indexedArtistName = indexedArtistName
    def add_indexedArtistName(self, value): self.indexedArtistName.append(value)
    def insert_indexedArtistName(self, index, value): self.indexedArtistName[index] = value
    def hasContent_(self):
        if (
            self.indexedArtistName
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indexedArtist', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indexedArtist')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indexedArtist'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indexedArtist', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for indexedArtistName_ in self.indexedArtistName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindexedArtistName>%s</%sindexedArtistName>%s' % (namespace_, self.gds_format_string(quote_xml(indexedArtistName_).encode(ExternalEncoding), input_name='indexedArtistName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='indexedArtist'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('indexedArtistName=[\n')
        level += 1
        for indexedArtistName_ in self.indexedArtistName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(indexedArtistName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indexedArtistName':
            indexedArtistName_ = child_.text
            indexedArtistName_ = self.gds_validate_string(indexedArtistName_, node, 'indexedArtistName')
            self.indexedArtistName.append(indexedArtistName_)
# end class indexedArtist


class masterGenres(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, genreName=None):
        if genreName is None:
            self.genreName = []
        else:
            self.genreName = genreName
    def factory(*args_, **kwargs_):
        if masterGenres.subclass:
            return masterGenres.subclass(*args_, **kwargs_)
        else:
            return masterGenres(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_genreName(self): return self.genreName
    def set_genreName(self, genreName): self.genreName = genreName
    def add_genreName(self, value): self.genreName.append(value)
    def insert_genreName(self, index, value): self.genreName[index] = value
    def hasContent_(self):
        if (
            self.genreName
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='masterGenres', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='masterGenres')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='masterGenres'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='masterGenres', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for genreName_ in self.genreName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgenreName>%s</%sgenreName>%s' % (namespace_, self.gds_format_string(quote_xml(genreName_).encode(ExternalEncoding), input_name='genreName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='masterGenres'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('genreName=[\n')
        level += 1
        for genreName_ in self.genreName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(genreName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'genreName':
            genreName_ = child_.text
            genreName_ = self.gds_validate_string(genreName_, node, 'genreName')
            self.genreName.append(genreName_)
# end class masterGenres


class masterStyles(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, genreName=None):
        if genreName is None:
            self.genreName = []
        else:
            self.genreName = genreName
    def factory(*args_, **kwargs_):
        if masterStyles.subclass:
            return masterStyles.subclass(*args_, **kwargs_)
        else:
            return masterStyles(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_genreName(self): return self.genreName
    def set_genreName(self, genreName): self.genreName = genreName
    def add_genreName(self, value): self.genreName.append(value)
    def insert_genreName(self, index, value): self.genreName[index] = value
    def hasContent_(self):
        if (
            self.genreName
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='masterStyles', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='masterStyles')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='masterStyles'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='masterStyles', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for genreName_ in self.genreName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgenreName>%s</%sgenreName>%s' % (namespace_, self.gds_format_string(quote_xml(genreName_).encode(ExternalEncoding), input_name='genreName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='masterStyles'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('genreName=[\n')
        level += 1
        for genreName_ in self.genreName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(genreName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'genreName':
            genreName_ = child_.text
            genreName_ = self.gds_validate_string(genreName_, node, 'genreName')
            self.genreName.append(genreName_)
# end class masterStyles


class crawlHistoryList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, crawlHistory=None):
        if crawlHistory is None:
            self.crawlHistory = []
        else:
            self.crawlHistory = crawlHistory
    def factory(*args_, **kwargs_):
        if crawlHistoryList.subclass:
            return crawlHistoryList.subclass(*args_, **kwargs_)
        else:
            return crawlHistoryList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_crawlHistory(self): return self.crawlHistory
    def set_crawlHistory(self, crawlHistory): self.crawlHistory = crawlHistory
    def add_crawlHistory(self, value): self.crawlHistory.append(value)
    def insert_crawlHistory(self, index, value): self.crawlHistory[index] = value
    def hasContent_(self):
        if (
            self.crawlHistory
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='crawlHistoryList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='crawlHistoryList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='crawlHistoryList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='crawlHistoryList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for crawlHistory_ in self.crawlHistory:
            crawlHistory_.export(outfile, level, namespace_, name_='crawlHistory', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='crawlHistoryList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('crawlHistory=[\n')
        level += 1
        for crawlHistory_ in self.crawlHistory:
            showIndent(outfile, level)
            outfile.write('model_.crawlHistory(\n')
            crawlHistory_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'crawlHistory':
            obj_ = crawlHistory.factory()
            obj_.build(child_)
            self.crawlHistory.append(obj_)
# end class crawlHistoryList


class crawlHistory(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Views=None, Date=None, Delta=None):
        self.Views = Views
        self.Date = Date
        self.Delta = Delta
    def factory(*args_, **kwargs_):
        if crawlHistory.subclass:
            return crawlHistory.subclass(*args_, **kwargs_)
        else:
            return crawlHistory(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Views(self): return self.Views
    def set_Views(self, Views): self.Views = Views
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_Delta(self): return self.Delta
    def set_Delta(self, Delta): self.Delta = Delta
    def hasContent_(self):
        if (
            self.Views is not None or
            self.Date is not None or
            self.Delta is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='crawlHistory', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='crawlHistory')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='crawlHistory'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='crawlHistory', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Views is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sViews>%s</%sViews>%s' % (namespace_, self.gds_format_integer(self.Views, input_name='Views'), namespace_, eol_))
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDate>%s</%sDate>%s' % (namespace_, self.gds_format_string(quote_xml(self.Date).encode(ExternalEncoding), input_name='Date'), namespace_, eol_))
        if self.Delta is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDelta>%s</%sDelta>%s' % (namespace_, self.gds_format_integer(self.Delta, input_name='Delta'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='crawlHistory'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Views is not None:
            showIndent(outfile, level)
            outfile.write('Views=%d,\n' % self.Views)
        if self.Date is not None:
            showIndent(outfile, level)
            outfile.write('Date=%s,\n' % quote_python(self.Date).encode(ExternalEncoding))
        if self.Delta is not None:
            showIndent(outfile, level)
            outfile.write('Delta=%d,\n' % self.Delta)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Views':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Views')
            self.Views = ival_
        elif nodeName_ == 'Date':
            Date_ = child_.text
            Date_ = self.gds_validate_string(Date_, node, 'Date')
            self.Date = Date_
        elif nodeName_ == 'Delta':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Delta')
            self.Delta = ival_
# end class crawlHistory


class genresCountList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, genresCount=None):
        if genresCount is None:
            self.genresCount = []
        else:
            self.genresCount = genresCount
    def factory(*args_, **kwargs_):
        if genresCountList.subclass:
            return genresCountList.subclass(*args_, **kwargs_)
        else:
            return genresCountList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_genresCount(self): return self.genresCount
    def set_genresCount(self, genresCount): self.genresCount = genresCount
    def add_genresCount(self, value): self.genresCount.append(value)
    def insert_genresCount(self, index, value): self.genresCount[index] = value
    def hasContent_(self):
        if (
            self.genresCount
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='genresCountList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='genresCountList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='genresCountList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='genresCountList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for genresCount_ in self.genresCount:
            genresCount_.export(outfile, level, namespace_, name_='genresCount', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='genresCountList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('genresCount=[\n')
        level += 1
        for genresCount_ in self.genresCount:
            showIndent(outfile, level)
            outfile.write('model_.genresCount(\n')
            genresCount_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'genresCount':
            obj_ = genresCount.factory()
            obj_.build(child_)
            self.genresCount.append(obj_)
# end class genresCountList


class genresCount(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Percentage=None, Count=None, Genre=None):
        self.Percentage = Percentage
        self.Count = Count
        self.Genre = Genre
    def factory(*args_, **kwargs_):
        if genresCount.subclass:
            return genresCount.subclass(*args_, **kwargs_)
        else:
            return genresCount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Percentage(self): return self.Percentage
    def set_Percentage(self, Percentage): self.Percentage = Percentage
    def get_Count(self): return self.Count
    def set_Count(self, Count): self.Count = Count
    def get_Genre(self): return self.Genre
    def set_Genre(self, Genre): self.Genre = Genre
    def hasContent_(self):
        if (
            self.Percentage is not None or
            self.Count is not None or
            self.Genre is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='genresCount', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='genresCount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='genresCount'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='genresCount', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Percentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPercentage>%s</%sPercentage>%s' % (namespace_, self.gds_format_float(self.Percentage, input_name='Percentage'), namespace_, eol_))
        if self.Count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCount>%s</%sCount>%s' % (namespace_, self.gds_format_integer(self.Count, input_name='Count'), namespace_, eol_))
        if self.Genre is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGenre>%s</%sGenre>%s' % (namespace_, self.gds_format_string(quote_xml(self.Genre).encode(ExternalEncoding), input_name='Genre'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='genresCount'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Percentage is not None:
            showIndent(outfile, level)
            outfile.write('Percentage=%f,\n' % self.Percentage)
        if self.Count is not None:
            showIndent(outfile, level)
            outfile.write('Count=%d,\n' % self.Count)
        if self.Genre is not None:
            showIndent(outfile, level)
            outfile.write('Genre=%s,\n' % quote_python(self.Genre).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Percentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Percentage')
            self.Percentage = fval_
        elif nodeName_ == 'Count':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Count')
            self.Count = ival_
        elif nodeName_ == 'Genre':
            Genre_ = child_.text
            Genre_ = self.gds_validate_string(Genre_, node, 'Genre')
            self.Genre = Genre_
# end class genresCount


class level1Genres(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, genreName=None):
        if genreName is None:
            self.genreName = []
        else:
            self.genreName = genreName
    def factory(*args_, **kwargs_):
        if level1Genres.subclass:
            return level1Genres.subclass(*args_, **kwargs_)
        else:
            return level1Genres(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_genreName(self): return self.genreName
    def set_genreName(self, genreName): self.genreName = genreName
    def add_genreName(self, value): self.genreName.append(value)
    def insert_genreName(self, index, value): self.genreName[index] = value
    def hasContent_(self):
        if (
            self.genreName
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='level1Genres', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='level1Genres')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='level1Genres'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='level1Genres', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for genreName_ in self.genreName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgenreName>%s</%sgenreName>%s' % (namespace_, self.gds_format_string(quote_xml(genreName_).encode(ExternalEncoding), input_name='genreName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='level1Genres'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('genreName=[\n')
        level += 1
        for genreName_ in self.genreName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(genreName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'genreName':
            genreName_ = child_.text
            genreName_ = self.gds_validate_string(genreName_, node, 'genreName')
            self.genreName.append(genreName_)
# end class level1Genres


class level2Genres(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, genreName=None):
        if genreName is None:
            self.genreName = []
        else:
            self.genreName = genreName
    def factory(*args_, **kwargs_):
        if level2Genres.subclass:
            return level2Genres.subclass(*args_, **kwargs_)
        else:
            return level2Genres(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_genreName(self): return self.genreName
    def set_genreName(self, genreName): self.genreName = genreName
    def add_genreName(self, value): self.genreName.append(value)
    def insert_genreName(self, index, value): self.genreName[index] = value
    def hasContent_(self):
        if (
            self.genreName
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='level2Genres', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='level2Genres')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='level2Genres'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='level2Genres', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for genreName_ in self.genreName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgenreName>%s</%sgenreName>%s' % (namespace_, self.gds_format_string(quote_xml(genreName_).encode(ExternalEncoding), input_name='genreName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='level2Genres'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('genreName=[\n')
        level += 1
        for genreName_ in self.genreName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(genreName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'genreName':
            genreName_ = child_.text
            genreName_ = self.gds_validate_string(genreName_, node, 'genreName')
            self.genreName.append(genreName_)
# end class level2Genres


class level3Genres(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, genreName=None):
        if genreName is None:
            self.genreName = []
        else:
            self.genreName = genreName
    def factory(*args_, **kwargs_):
        if level3Genres.subclass:
            return level3Genres.subclass(*args_, **kwargs_)
        else:
            return level3Genres(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_genreName(self): return self.genreName
    def set_genreName(self, genreName): self.genreName = genreName
    def add_genreName(self, value): self.genreName.append(value)
    def insert_genreName(self, index, value): self.genreName[index] = value
    def hasContent_(self):
        if (
            self.genreName
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='level3Genres', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='level3Genres')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='level3Genres'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='level3Genres', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for genreName_ in self.genreName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgenreName>%s</%sgenreName>%s' % (namespace_, self.gds_format_string(quote_xml(genreName_).encode(ExternalEncoding), input_name='genreName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='level3Genres'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('genreName=[\n')
        level += 1
        for genreName_ in self.genreName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(genreName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'genreName':
            genreName_ = child_.text
            genreName_ = self.gds_validate_string(genreName_, node, 'genreName')
            self.genreName.append(genreName_)
# end class level3Genres


class level4Genres(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, genreName=None):
        if genreName is None:
            self.genreName = []
        else:
            self.genreName = genreName
    def factory(*args_, **kwargs_):
        if level4Genres.subclass:
            return level4Genres.subclass(*args_, **kwargs_)
        else:
            return level4Genres(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_genreName(self): return self.genreName
    def set_genreName(self, genreName): self.genreName = genreName
    def add_genreName(self, value): self.genreName.append(value)
    def insert_genreName(self, index, value): self.genreName[index] = value
    def hasContent_(self):
        if (
            self.genreName
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='level4Genres', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='level4Genres')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='level4Genres'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='level4Genres', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for genreName_ in self.genreName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgenreName>%s</%sgenreName>%s' % (namespace_, self.gds_format_string(quote_xml(genreName_).encode(ExternalEncoding), input_name='genreName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='level4Genres'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('genreName=[\n')
        level += 1
        for genreName_ in self.genreName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(genreName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'genreName':
            genreName_ = child_.text
            genreName_ = self.gds_validate_string(genreName_, node, 'genreName')
            self.genreName.append(genreName_)
# end class level4Genres


class level5Genres(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, genreName=None):
        if genreName is None:
            self.genreName = []
        else:
            self.genreName = genreName
    def factory(*args_, **kwargs_):
        if level5Genres.subclass:
            return level5Genres.subclass(*args_, **kwargs_)
        else:
            return level5Genres(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_genreName(self): return self.genreName
    def set_genreName(self, genreName): self.genreName = genreName
    def add_genreName(self, value): self.genreName.append(value)
    def insert_genreName(self, index, value): self.genreName[index] = value
    def hasContent_(self):
        if (
            self.genreName
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='level5Genres', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='level5Genres')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='level5Genres'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='level5Genres', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for genreName_ in self.genreName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgenreName>%s</%sgenreName>%s' % (namespace_, self.gds_format_string(quote_xml(genreName_).encode(ExternalEncoding), input_name='genreName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='level5Genres'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('genreName=[\n')
        level += 1
        for genreName_ in self.genreName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(genreName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'genreName':
            genreName_ = child_.text
            genreName_ = self.gds_validate_string(genreName_, node, 'genreName')
            self.genreName.append(genreName_)
# end class level5Genres


class level6Genres(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, genreName=None):
        if genreName is None:
            self.genreName = []
        else:
            self.genreName = genreName
    def factory(*args_, **kwargs_):
        if level6Genres.subclass:
            return level6Genres.subclass(*args_, **kwargs_)
        else:
            return level6Genres(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_genreName(self): return self.genreName
    def set_genreName(self, genreName): self.genreName = genreName
    def add_genreName(self, value): self.genreName.append(value)
    def insert_genreName(self, index, value): self.genreName[index] = value
    def hasContent_(self):
        if (
            self.genreName
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='level6Genres', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='level6Genres')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='level6Genres'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='level6Genres', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for genreName_ in self.genreName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgenreName>%s</%sgenreName>%s' % (namespace_, self.gds_format_string(quote_xml(genreName_).encode(ExternalEncoding), input_name='genreName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='level6Genres'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('genreName=[\n')
        level += 1
        for genreName_ in self.genreName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(genreName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'genreName':
            genreName_ = child_.text
            genreName_ = self.gds_validate_string(genreName_, node, 'genreName')
            self.genreName.append(genreName_)
# end class level6Genres


class level7Genres(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, genreName=None):
        if genreName is None:
            self.genreName = []
        else:
            self.genreName = genreName
    def factory(*args_, **kwargs_):
        if level7Genres.subclass:
            return level7Genres.subclass(*args_, **kwargs_)
        else:
            return level7Genres(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_genreName(self): return self.genreName
    def set_genreName(self, genreName): self.genreName = genreName
    def add_genreName(self, value): self.genreName.append(value)
    def insert_genreName(self, index, value): self.genreName[index] = value
    def hasContent_(self):
        if (
            self.genreName
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='level7Genres', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='level7Genres')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='level7Genres'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='level7Genres', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for genreName_ in self.genreName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgenreName>%s</%sgenreName>%s' % (namespace_, self.gds_format_string(quote_xml(genreName_).encode(ExternalEncoding), input_name='genreName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='level7Genres'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('genreName=[\n')
        level += 1
        for genreName_ in self.genreName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(genreName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'genreName':
            genreName_ = child_.text
            genreName_ = self.gds_validate_string(genreName_, node, 'genreName')
            self.genreName.append(genreName_)
# end class level7Genres


class level8Genres(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, genreName=None):
        if genreName is None:
            self.genreName = []
        else:
            self.genreName = genreName
    def factory(*args_, **kwargs_):
        if level8Genres.subclass:
            return level8Genres.subclass(*args_, **kwargs_)
        else:
            return level8Genres(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_genreName(self): return self.genreName
    def set_genreName(self, genreName): self.genreName = genreName
    def add_genreName(self, value): self.genreName.append(value)
    def insert_genreName(self, index, value): self.genreName[index] = value
    def hasContent_(self):
        if (
            self.genreName
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='level8Genres', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='level8Genres')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='level8Genres'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='level8Genres', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for genreName_ in self.genreName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgenreName>%s</%sgenreName>%s' % (namespace_, self.gds_format_string(quote_xml(genreName_).encode(ExternalEncoding), input_name='genreName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='level8Genres'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('genreName=[\n')
        level += 1
        for genreName_ in self.genreName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(genreName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'genreName':
            genreName_ = child_.text
            genreName_ = self.gds_validate_string(genreName_, node, 'genreName')
            self.genreName.append(genreName_)
# end class level8Genres


class level9Genres(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, genreName=None):
        if genreName is None:
            self.genreName = []
        else:
            self.genreName = genreName
    def factory(*args_, **kwargs_):
        if level9Genres.subclass:
            return level9Genres.subclass(*args_, **kwargs_)
        else:
            return level9Genres(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_genreName(self): return self.genreName
    def set_genreName(self, genreName): self.genreName = genreName
    def add_genreName(self, value): self.genreName.append(value)
    def insert_genreName(self, index, value): self.genreName[index] = value
    def hasContent_(self):
        if (
            self.genreName
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='level9Genres', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='level9Genres')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='level9Genres'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='level9Genres', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for genreName_ in self.genreName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgenreName>%s</%sgenreName>%s' % (namespace_, self.gds_format_string(quote_xml(genreName_).encode(ExternalEncoding), input_name='genreName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='level9Genres'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('genreName=[\n')
        level += 1
        for genreName_ in self.genreName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(genreName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'genreName':
            genreName_ = child_.text
            genreName_ = self.gds_validate_string(genreName_, node, 'genreName')
            self.genreName.append(genreName_)
# end class level9Genres


class albumList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, album=None):
        if album is None:
            self.album = []
        else:
            self.album = album
    def factory(*args_, **kwargs_):
        if albumList.subclass:
            return albumList.subclass(*args_, **kwargs_)
        else:
            return albumList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_album(self): return self.album
    def set_album(self, album): self.album = album
    def add_album(self, value): self.album.append(value)
    def insert_album(self, index, value): self.album[index] = value
    def hasContent_(self):
        if (
            self.album
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='albumList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='albumList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='albumList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='albumList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for album_ in self.album:
            album_.export(outfile, level, namespace_, name_='album', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='albumList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('album=[\n')
        level += 1
        for album_ in self.album:
            showIndent(outfile, level)
            outfile.write('model_.album(\n')
            album_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'album':
            obj_ = album.factory()
            obj_.build(child_)
            self.album.append(obj_)
# end class albumList


class album(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, albumName=None, albumReleasedate=None, country=None, language=None, barCode=None, catalogue=None, label=None):
        self.albumName = albumName
        self.albumReleasedate = albumReleasedate
        self.country = country
        self.language = language
        self.barCode = barCode
        self.catalogue = catalogue
        self.label = label
    def factory(*args_, **kwargs_):
        if album.subclass:
            return album.subclass(*args_, **kwargs_)
        else:
            return album(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_albumName(self): return self.albumName
    def set_albumName(self, albumName): self.albumName = albumName
    def get_albumReleasedate(self): return self.albumReleasedate
    def set_albumReleasedate(self, albumReleasedate): self.albumReleasedate = albumReleasedate
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_barCode(self): return self.barCode
    def set_barCode(self, barCode): self.barCode = barCode
    def get_catalogue(self): return self.catalogue
    def set_catalogue(self, catalogue): self.catalogue = catalogue
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def hasContent_(self):
        if (
            self.albumName is not None or
            self.albumReleasedate is not None or
            self.country is not None or
            self.language is not None or
            self.barCode is not None or
            self.catalogue is not None or
            self.label is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='album', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='album')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='album'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='album', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.albumName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%salbumName>%s</%salbumName>%s' % (namespace_, self.gds_format_string(quote_xml(self.albumName).encode(ExternalEncoding), input_name='albumName'), namespace_, eol_))
        if self.albumReleasedate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%salbumReleasedate>%s</%salbumReleasedate>%s' % (namespace_, self.gds_format_integer(self.albumReleasedate, input_name='albumReleasedate'), namespace_, eol_))
        if self.country is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scountry>%s</%scountry>%s' % (namespace_, self.gds_format_string(quote_xml(self.country).encode(ExternalEncoding), input_name='country'), namespace_, eol_))
        if self.language is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slanguage>%s</%slanguage>%s' % (namespace_, self.gds_format_string(quote_xml(self.language).encode(ExternalEncoding), input_name='language'), namespace_, eol_))
        if self.barCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbarCode>%s</%sbarCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.barCode).encode(ExternalEncoding), input_name='barCode'), namespace_, eol_))
        if self.catalogue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scatalogue>%s</%scatalogue>%s' % (namespace_, self.gds_format_string(quote_xml(self.catalogue).encode(ExternalEncoding), input_name='catalogue'), namespace_, eol_))
        if self.label is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slabel>%s</%slabel>%s' % (namespace_, self.gds_format_string(quote_xml(self.label).encode(ExternalEncoding), input_name='label'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='album'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.albumName is not None:
            showIndent(outfile, level)
            outfile.write('albumName=%s,\n' % quote_python(self.albumName).encode(ExternalEncoding))
        if self.albumReleasedate is not None:
            showIndent(outfile, level)
            outfile.write('albumReleasedate=%d,\n' % self.albumReleasedate)
        if self.country is not None:
            showIndent(outfile, level)
            outfile.write('country=%s,\n' % quote_python(self.country).encode(ExternalEncoding))
        if self.language is not None:
            showIndent(outfile, level)
            outfile.write('language=%s,\n' % quote_python(self.language).encode(ExternalEncoding))
        if self.barCode is not None:
            showIndent(outfile, level)
            outfile.write('barCode=%s,\n' % quote_python(self.barCode).encode(ExternalEncoding))
        if self.catalogue is not None:
            showIndent(outfile, level)
            outfile.write('catalogue=%s,\n' % quote_python(self.catalogue).encode(ExternalEncoding))
        if self.label is not None:
            showIndent(outfile, level)
            outfile.write('label=%s,\n' % quote_python(self.label).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'albumName':
            albumName_ = child_.text
            albumName_ = self.gds_validate_string(albumName_, node, 'albumName')
            self.albumName = albumName_
        elif nodeName_ == 'albumReleasedate':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'albumReleasedate')
            self.albumReleasedate = ival_
        elif nodeName_ == 'country':
            country_ = child_.text
            country_ = self.gds_validate_string(country_, node, 'country')
            self.country = country_
        elif nodeName_ == 'language':
            language_ = child_.text
            language_ = self.gds_validate_string(language_, node, 'language')
            self.language = language_
        elif nodeName_ == 'barCode':
            barCode_ = child_.text
            barCode_ = self.gds_validate_string(barCode_, node, 'barCode')
            self.barCode = barCode_
        elif nodeName_ == 'catalogue':
            catalogue_ = child_.text
            catalogue_ = self.gds_validate_string(catalogue_, node, 'catalogue')
            self.catalogue = catalogue_
        elif nodeName_ == 'label':
            label_ = child_.text
            label_ = self.gds_validate_string(label_, node, 'label')
            self.label = label_
# end class album


class youtubeList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, video=None):
        if video is None:
            self.video = []
        else:
            self.video = video
    def factory(*args_, **kwargs_):
        if youtubeList.subclass:
            return youtubeList.subclass(*args_, **kwargs_)
        else:
            return youtubeList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_video(self): return self.video
    def set_video(self, video): self.video = video
    def add_video(self, value): self.video.append(value)
    def insert_video(self, index, value): self.video[index] = value
    def hasContent_(self):
        if (
            self.video
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='youtubeList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='youtubeList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='youtubeList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='youtubeList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for video_ in self.video:
            video_.export(outfile, level, namespace_, name_='video', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='youtubeList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('video=[\n')
        level += 1
        for video_ in self.video:
            showIndent(outfile, level)
            outfile.write('model_.video(\n')
            video_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'video':
            obj_ = video.factory()
            obj_.build(child_)
            self.video.append(obj_)
# end class youtubeList


class video(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, startTime=None, endTime=None, totalTime=None, viewcountRate=None, viewcount=None, rating=None):
        self.Id = Id
        self.startTime = startTime
        self.endTime = endTime
        self.totalTime = totalTime
        self.viewcountRate = viewcountRate
        self.viewcount = viewcount
        self.rating = rating
    def factory(*args_, **kwargs_):
        if video.subclass:
            return video.subclass(*args_, **kwargs_)
        else:
            return video(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_startTime(self): return self.startTime
    def set_startTime(self, startTime): self.startTime = startTime
    def get_endTime(self): return self.endTime
    def set_endTime(self, endTime): self.endTime = endTime
    def get_totalTime(self): return self.totalTime
    def set_totalTime(self, totalTime): self.totalTime = totalTime
    def get_viewcountRate(self): return self.viewcountRate
    def set_viewcountRate(self, viewcountRate): self.viewcountRate = viewcountRate
    def get_viewcount(self): return self.viewcount
    def set_viewcount(self, viewcount): self.viewcount = viewcount
    def get_rating(self): return self.rating
    def set_rating(self, rating): self.rating = rating
    def hasContent_(self):
        if (
            self.Id is not None or
            self.startTime is not None or
            self.endTime is not None or
            self.totalTime is not None or
            self.viewcountRate is not None or
            self.viewcount is not None or
            self.rating is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='video', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='video')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='video'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='video', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_format_string(quote_xml(self.Id).encode(ExternalEncoding), input_name='Id'), namespace_, eol_))
        if self.startTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstartTime>%s</%sstartTime>%s' % (namespace_, self.gds_format_integer(self.startTime, input_name='startTime'), namespace_, eol_))
        if self.endTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendTime>%s</%sendTime>%s' % (namespace_, self.gds_format_integer(self.endTime, input_name='endTime'), namespace_, eol_))
        if self.totalTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalTime>%s</%stotalTime>%s' % (namespace_, self.gds_format_integer(self.totalTime, input_name='totalTime'), namespace_, eol_))
        if self.viewcountRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sviewcountRate>%s</%sviewcountRate>%s' % (namespace_, self.gds_format_float(self.viewcountRate, input_name='viewcountRate'), namespace_, eol_))
        if self.viewcount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sviewcount>%s</%sviewcount>%s' % (namespace_, self.gds_format_integer(self.viewcount, input_name='viewcount'), namespace_, eol_))
        if self.rating is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srating>%s</%srating>%s' % (namespace_, self.gds_format_float(self.rating, input_name='rating'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='video'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id=%s,\n' % quote_python(self.Id).encode(ExternalEncoding))
        if self.startTime is not None:
            showIndent(outfile, level)
            outfile.write('startTime=%d,\n' % self.startTime)
        if self.endTime is not None:
            showIndent(outfile, level)
            outfile.write('endTime=%d,\n' % self.endTime)
        if self.totalTime is not None:
            showIndent(outfile, level)
            outfile.write('totalTime=%d,\n' % self.totalTime)
        if self.viewcountRate is not None:
            showIndent(outfile, level)
            outfile.write('viewcountRate=%f,\n' % self.viewcountRate)
        if self.viewcount is not None:
            showIndent(outfile, level)
            outfile.write('viewcount=%d,\n' % self.viewcount)
        if self.rating is not None:
            showIndent(outfile, level)
            outfile.write('rating=%f,\n' % self.rating)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
        elif nodeName_ == 'startTime':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'startTime')
            self.startTime = ival_
        elif nodeName_ == 'endTime':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'endTime')
            self.endTime = ival_
        elif nodeName_ == 'totalTime':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalTime')
            self.totalTime = ival_
        elif nodeName_ == 'viewcountRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'viewcountRate')
            self.viewcountRate = fval_
        elif nodeName_ == 'viewcount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'viewcount')
            self.viewcount = ival_
        elif nodeName_ == 'rating':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'rating')
            self.rating = fval_
# end class video


class soundcloudList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, audio=None):
        if audio is None:
            self.audio = []
        else:
            self.audio = audio
    def factory(*args_, **kwargs_):
        if soundcloudList.subclass:
            return soundcloudList.subclass(*args_, **kwargs_)
        else:
            return soundcloudList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_audio(self): return self.audio
    def set_audio(self, audio): self.audio = audio
    def add_audio(self, value): self.audio.append(value)
    def insert_audio(self, index, value): self.audio[index] = value
    def hasContent_(self):
        if (
            self.audio
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='soundcloudList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='soundcloudList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='soundcloudList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='soundcloudList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for audio_ in self.audio:
            audio_.export(outfile, level, namespace_, name_='audio', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='soundcloudList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('audio=[\n')
        level += 1
        for audio_ in self.audio:
            showIndent(outfile, level)
            outfile.write('model_.audio(\n')
            audio_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'audio':
            obj_ = audio.factory()
            obj_.build(child_)
            self.audio.append(obj_)
# end class soundcloudList


class audio(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, soundcloudUrl=None, soundcloudViewcount=None, soundcloudLikes=None, soundcloudGenres=None):
        self.soundcloudUrl = soundcloudUrl
        self.soundcloudViewcount = soundcloudViewcount
        self.soundcloudLikes = soundcloudLikes
        self.soundcloudGenres = soundcloudGenres
    def factory(*args_, **kwargs_):
        if audio.subclass:
            return audio.subclass(*args_, **kwargs_)
        else:
            return audio(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_soundcloudUrl(self): return self.soundcloudUrl
    def set_soundcloudUrl(self, soundcloudUrl): self.soundcloudUrl = soundcloudUrl
    def get_soundcloudViewcount(self): return self.soundcloudViewcount
    def set_soundcloudViewcount(self, soundcloudViewcount): self.soundcloudViewcount = soundcloudViewcount
    def get_soundcloudLikes(self): return self.soundcloudLikes
    def set_soundcloudLikes(self, soundcloudLikes): self.soundcloudLikes = soundcloudLikes
    def get_soundcloudGenres(self): return self.soundcloudGenres
    def set_soundcloudGenres(self, soundcloudGenres): self.soundcloudGenres = soundcloudGenres
    def hasContent_(self):
        if (
            self.soundcloudUrl is not None or
            self.soundcloudViewcount is not None or
            self.soundcloudLikes is not None or
            self.soundcloudGenres is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='audio', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='audio')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='audio'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='audio', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.soundcloudUrl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssoundcloudUrl>%s</%ssoundcloudUrl>%s' % (namespace_, self.gds_format_string(quote_xml(self.soundcloudUrl).encode(ExternalEncoding), input_name='soundcloudUrl'), namespace_, eol_))
        if self.soundcloudViewcount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssoundcloudViewcount>%s</%ssoundcloudViewcount>%s' % (namespace_, self.gds_format_integer(self.soundcloudViewcount, input_name='soundcloudViewcount'), namespace_, eol_))
        if self.soundcloudLikes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssoundcloudLikes>%s</%ssoundcloudLikes>%s' % (namespace_, self.gds_format_integer(self.soundcloudLikes, input_name='soundcloudLikes'), namespace_, eol_))
        if self.soundcloudGenres is not None:
            self.soundcloudGenres.export(outfile, level, namespace_, name_='soundcloudGenres', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='audio'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.soundcloudUrl is not None:
            showIndent(outfile, level)
            outfile.write('soundcloudUrl=%s,\n' % quote_python(self.soundcloudUrl).encode(ExternalEncoding))
        if self.soundcloudViewcount is not None:
            showIndent(outfile, level)
            outfile.write('soundcloudViewcount=%d,\n' % self.soundcloudViewcount)
        if self.soundcloudLikes is not None:
            showIndent(outfile, level)
            outfile.write('soundcloudLikes=%d,\n' % self.soundcloudLikes)
        if self.soundcloudGenres is not None:
            showIndent(outfile, level)
            outfile.write('soundcloudGenres=model_.soundcloudGenres(\n')
            self.soundcloudGenres.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'soundcloudUrl':
            soundcloudUrl_ = child_.text
            soundcloudUrl_ = self.gds_validate_string(soundcloudUrl_, node, 'soundcloudUrl')
            self.soundcloudUrl = soundcloudUrl_
        elif nodeName_ == 'soundcloudViewcount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'soundcloudViewcount')
            self.soundcloudViewcount = ival_
        elif nodeName_ == 'soundcloudLikes':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'soundcloudLikes')
            self.soundcloudLikes = ival_
        elif nodeName_ == 'soundcloudGenres':
            obj_ = soundcloudGenres.factory()
            obj_.build(child_)
            self.set_soundcloudGenres(obj_)
# end class audio


class soundcloudGenres(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, genreName=None):
        if genreName is None:
            self.genreName = []
        else:
            self.genreName = genreName
    def factory(*args_, **kwargs_):
        if soundcloudGenres.subclass:
            return soundcloudGenres.subclass(*args_, **kwargs_)
        else:
            return soundcloudGenres(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_genreName(self): return self.genreName
    def set_genreName(self, genreName): self.genreName = genreName
    def add_genreName(self, value): self.genreName.append(value)
    def insert_genreName(self, index, value): self.genreName[index] = value
    def hasContent_(self):
        if (
            self.genreName
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='soundcloudGenres', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='soundcloudGenres')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='soundcloudGenres'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='soundcloudGenres', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for genreName_ in self.genreName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgenreName>%s</%sgenreName>%s' % (namespace_, self.gds_format_string(quote_xml(genreName_).encode(ExternalEncoding), input_name='genreName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='soundcloudGenres'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('genreName=[\n')
        level += 1
        for genreName_ in self.genreName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(genreName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'genreName':
            genreName_ = child_.text
            genreName_ = self.gds_validate_string(genreName_, node, 'genreName')
            self.genreName.append(genreName_)
# end class soundcloudGenres


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'songs'
        rootClass = songs
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    #sys.stdout.write('<?xml version="1.0" ?>\n')
    '''rootObj.export(sys.stdout, 0, name_=rootTag,
        namespacedef_='',
        pretty_print=True)'''
    return rootObj


def parseEtree(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'songs'
        rootClass = songs
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    rootElement = rootObj.to_etree(None, name_=rootTag)
    content = etree_.tostring(rootElement, pretty_print=True,
        xml_declaration=True, encoding="utf-8")
    sys.stdout.write(content)
    sys.stdout.write('\n')
    return rootObj, rootElement


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'songs'
        rootClass = songs
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="songs",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'songs'
        rootClass = songs
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from songs_api import *\n\n')
    sys.stdout.write('from datetime import datetime as datetime_\n\n')
    sys.stdout.write('import songs_api as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "album",
    "albumList",
    "artist",
    "audio",
    "connPhraseList",
    "crawlHistory",
    "crawlHistoryList",
    "ftArtistList",
    "genresCount",
    "genresCountList",
    "indexedArtist",
    "indexedArtistAliasList",
    "indexedftArtistList",
    "level1Genres",
    "level2Genres",
    "level3Genres",
    "level4Genres",
    "level5Genres",
    "level6Genres",
    "level7Genres",
    "level8Genres",
    "level9Genres",
    "masterGenres",
    "masterStyles",
    "songs",
    "soundcloudGenres",
    "soundcloudList",
    "video",
    "youtubeList"
    ]
